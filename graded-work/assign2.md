---
title: Assignment 2
layout: default
---

## BTI425 Assignment 2

<div style="background-color: yellow; border: 1px solid black; padding: 0.5em;">
<p><b>Notice</b><br>The course delivery and its dates and times have been affected by the worldwide novel coronavirus crisis. The content on this website may change frequently, so please refresh your viewer when consuming or reviewing content.</p>
</div>

<br>

The purpose or objective of the assignment is to create a substantial Angular app that interacts with a web API.

Read/skim all of this document before you begin work.

<br>

<span style="color: red;">Notice:  
Almost done editing. The web API text is complete.  
The work to be done in the Angular app will use the web API resources, so you can predict what the Angular app must do. After the Friday March 13 class, in which "forms" are discussed again, this document will be updated again, with an example of a sample strategy for designing and using your Angular components.</span> 

<br>

While you are doing the work, if a *specific task* is not clear, or it seems to require an unreasonable amount of time to complete, or it seems to require knowledge way beyond the content we've covered in the course, please don't hesistate to contact your professor. 

> You should NOT have to search for or locate resources "out there" in an effort to complete this work.  
> The resources provided in this course - notes, linked content, code examples - provide sufficient coverage. Review them frequently.  
> If you think that you will find "the answer" to this assignment somewhere "out there", you're wrong. Use the course resources as your shortcut. 

<br>

### Due Date

Tuesday, March 31, 2020, at 11:00pm ET

Grade value: 25% of your final course grade

*If you wish to submit the assignment before the due date and time, you can do that.*

<br>

### Overview and purpose

As noted above, the purpose or objective of the assignment is to create a web API and an Angular app that has good coverage of the topics in the course. 

The app's purpose is to define or translate the English-language terminology we use in the computer programming courses in the School of SDDS, for use by all students, whether or not English is a student's first language. 

We have so many students who are learning English and computer programming at the same time, and that is a challenging combination. The technical terminology is often unclear, complicated, and sometimes isn't explained well. For example, when we say "asynchronous", what does it clearly mean in English, as well as in a student's first language?

The general functionality of the user app will likely include:
* View and browse a list of all terms
* Search for a term, in any language
* View details about a term, and its meaning in English and in other languages
* Add a new term, English, or in another language (including its first or initial definition)
* For an existing term (English or other), add another definition/data

In summary, the app would have some of the utility of a dictionary, Wikipedia, and other resources (including this course's notes and learning resources). 

A web API will hold the data for the app. To enable scale and crowd-sourcing of data, the professors will also publish a web API that will be designed to aggregate (with some data entry *done by you*) the terms that each student enters, for the benefit of ALL students. More info about this is below.

The web API will be posted to Heroku and Atlas, and will provide the data for the Angular app. The Angular app will also be deployed to a public host (Heroku), so that you can deliver it to other devices (including, for example, your smartphone).  

Here's a diagram that shows the relationships among your browser, the deployed Angular app, and the deployed web API. Right-click and open it in a new tab/window to view it full size. 

<img style="max-width: 300px;" class="border1 img-responsive" alt="Relationships" title="Relationships" src="media/a2-app-hosting.png" />

<br>

#### Where this idea came from 

Recently, in our School of SDDS, some of the web programming teachers have decided to use the course sequence (and particularly this course) as a way to create and deliver software that could be used by our School community (students and faculty) and improved over time (by students and faculty). 

A number of app ideas were developed, and this idea was selected to be worked on in the Winter 2020 academic term. 

<br>

### Getting started, web API

Use `npm init` to initialize a new folder, probably named `a2-web-api`. Alternatively, use a code example from the repo as a base for your project work. 

<br>

#### Data schemas 

As implied above, data for the app will be generated by you (the student) as you work on the app. In addition, the professors will publish a web API that will aggregate and share the data generated by all students. More info about is found below. 

For this Assignment 2, the database will include two collections:
* terms in English 
  * includes an embedded subdocument collection, definitions in English
* terms in other languages 
  * includes an embedded subdocument collection, definitions in other languages

As suggested by this list of collections, a *term* could have zero or more *definitions*. This idea supports alternative or evolving definitions over time. It is implemented as a one-to-many association or relationship that uses the MongoDB "embedded document" technique: In a English term document, it has a field that stores a collection (i.e. an array) of "definition" *subdocuments*.  

> Review the embedded subdocument coverage in the [introduction](/notes/data-assoc-intro) note and in the [how-to](/notes/data-assoc-subdocs-how-to) note. 

> The embedded subdocument must be described by a Mongoose schema.  
> Therefore, the web API will have three Mongoose schemas:  
> 1. definition 
> 2. terms in English (maybe named "termEnglish")  
> 3. terms in other languages (maybe named termNonEnglish")  

<br>

Each term collection will have the same data fields:

Assignment 2 "termEnglish" schema fields:
* wordEnglish
* wordNonEnglish
* wordExpanded
* languageCode
* image
* imageType
* audio
* audioType
* linkAuthoritative
* linkWikipedia
* linkYouTube
* authorName
* dateCreated (date)
* dateRevised (date)
* fieldOfStudy
* helpYes (integer)
* helpNo (integer)
* definitions (array of "definition" objects)

The "termNonEnglish" schema will be the same, and it will *also* <br>have a field (probably named "termEnglishId") that will be <br>a document reference to the English term. 

Assignment 2 "definition" schema fields:
* authorName
* dateCreated (date)
* definition
* quality (integer)
* likes (integer)

<br>

In addition, an item in the English collection will be associated or related, in a one-to-many manner, with zero or more items in the non-English collection. It is implemented using the MongoDB "document reference" technique: In a *non-English term document*, it has a field (probably named "termEnglishId") that stores an object identifier "reference" to the English term document. 

> Review the document reference coverage in the [introduction](/notes/data-assoc-intro) note and in the [how-to](/notes/data-assoc-doc-ref-how-to) note. 

If you need a reminder about working with the MongoDB database engine, we suggest that you do these tasks:
* Create a database named `db-a2` (database for Assignment 2)
* In `db-a2`, create a collections likely named `TermsEnglish` and `TermsOther`

<br>

#### More explanations about some of the schema fields

The two "term" schemas are almost the same, by design. We wanted to make it easier to program by enabling copy-paste. Despite this, there are a few considerations which will affect your programming later on. Here's how some of the fields will be used. 

* `wordEnglish`  
Required  
The term, in English  
This will be present (non-empty) in both kinds of objects, termEnglish and termNonEnglish  
It will be unique too  

* `wordNonEnglish`  
The term, in another language  
This will be empty in termEnglish, and present in termNonEnglish  

* `wordExpanded`  
If the wordEnglish is an acronym or initialism, this will have the expansion  
For example, JSON and "JavaScript Object Notation"  
Otherwise, it will be empty  

* `languageCode`  
Required  
The ISO and *de facto* standardized codes for a language  
For example "en" for English, or "en-ca" for English (Canada)  
For termEnglish items, it will be one of the language codes that begin with "en"  
For termNonEnglish items, it will be one of the others  
Below, there is a link to a downloadable file of language codes that will be supported in the app  

* `image`, `imageType`, `audio`, and `audioType`  
We will use these in a future class/lesson  
For now, they can be empty  
They will hold file names (image and audio) for non-text media items for a term (e.g. a diagram or its pronounciation)  
(imageType and audioType are internet media type strings, e.g. "image/png")  

* `linkAuthoritative`, `linkWikipedia`, and `linkYouTube`  
URLs to web resources for the term  
Can be present or empty  
The "linkAuthoritative" is a link to the term's authoritative info source  
For example, for Node.js, it's https://nodejs.org

* `authorName`  
Required  
Your name  

* `dateCreated` and `dateRevised`  
Required  
These values are set in program code  
Do NOT get them from the app's user  

* `fieldOfStudy`  
Probably "computer programming" for our terms  
The course professors foresee that this app can be used by learners in any field of study, and not just ours, so that's its purpose - to identify the term's field of study

* `helpYes` and `helpNo`  
There will be a user interface (UI) item that will enable these values to be incremented  
Obviously, with enablement by the web API  
The idea is that we could ask the user whether the term they were looking at was hepful or not (to their learning)

* `definitions`  
A collection of one or more "definition" documents  
It is always possible for someone to have an alternate or better definition than an existing one  
It's also possible that a term (e.g. "server") could have multiple and somewhat different definitions    

* For a termNonEnglish document... `termEnglishId`  
Required (for a termNonEnglish document  
It is the object identifier of the termEnglish it's related to 

In the "definition" schema...

* `authorName`  
Required  
Your name  

* `dateCreated`  
Required  
This value is set in program code  
Do NOT get it from the app's user  

* `definition`  
Required  
The actual possibly-lengthy *definition* or explanation of the term  
The text format will be HTML  
And, the plan is that the content will use the language's character set  

* `quality`  
Ignore this for now; for future use  
(A human and/or AI-ML curator could assign a quality rating value to the definition)  

* `likes`  
There will be a user interface (UI) item that will enable this value to be incremented  
Obviously, with enablement by the web API  
The idea is that the user could quickly and easily indicate whether they "like" the specific definition

<br>

#### Data service tasks 

The data service tasks are similar for each entity (termEnglish and termNonEnglish). As you would predict, 

We suggest that you write the method pairs (in `server.js` and `manager.js`) for the termEnglish entity first, and thoroughly test them. Then, you will be able to essentially copy-paste-and-edit them for use for the termNonEnglish entity. The "add new" task will be slightly different in the termNonEnglish method pair, because we must use the object identifier for the related termEnglish document. 

During the code-writing process, test frequently with Postman. 

It is expected that the following, at a minimum, will be needed for the **termEnglish** entity:
* get all (sorted) 
* get one, by object identifier 
* get one, by "wordEnglish" 
* add new (termEnglish document, including one definition embedded subdocument) 
* edit existing (termEnglish document), to add a *new* definition 
* edit existing (termEnglish document), to increment the "helpYes" value
* edit existing (termEnglish document), to increment the "helpNo" value
* edit existing (definition document), to increment the "likes" value

> Reminder about the associated/related data coverage and how-to notes.

Time permitting, it may require another method pair to support the text editing of the definition's text. 

It is expected that the following, at a minimum, will be needed for the **termNonEnglish** entity:
* get all (sorted) (it's possible that the app won't need to use this)
* get one, by object identifier 
* get one, by "wordNonEnglish" 
* add new (termNonEnglish document, including one definition embedded subdocument) 
* edit existing (termNonEnglish document), to add a *new* definition 
* edit existing (termNonEnglish document), to increment the "helpYes" value
* edit existing (termNonEnglish document), to increment the "helpNo" value
* edit existing (definition document), to increment the "likes" value

<br>

#### Get large amounts of data (eventually!)

As noted above, the professor version of the web API has been published here:

[Professor Assignment 2 web API](https://pam-2020-a2and3webapi.herokuapp.com/api)

Here's the plain text URL:  
`https://pam-2020-a2and3webapi.herokuapp.com/api`

Using Postman, you can add these segments to the URL, and interact with the web API:

* `/terms/english`  
All terms in English 

* `/terms/english/XXXXXX...`  
One term, in English, for a specific identifier 

* `/terms/other`  
All terms in other languages

* `/terms/other/XXXXXX...`  
One non-English term, for a specific identifier 

In addition, you can add a new English term (with its initial definition), using this URL:
* `/terms/english`  
Obviously POST, application/json, and a JSON entity body  

And, for an *existing* English term, you can add another definition, using this URL:
* `/terms/english/XXXXXX.../add-definition`  
PUT, application/json, and a JSON entity body  

As you would expect, you can add a new non-English term (with its initial definition), using this URL:
* `/terms/other`  
POST, application/json, and a JSON entity body  

Finally, for an *existing* non-English term, you can add another definition, using this URL:
* `/terms/other/XXXXXX.../add-definition`  
PUT, application/json, and a JSON entity body  

<mark>To help yourself, and your fellow students,</mark> plan on using Postman and adding at least one English term and one non-English term to the professor web API. We also suggest that you add another definition to a term (one English and one non-English). 

> Data entry tips:
> * Send a "get one" request to get the JSON for one term  
> * That will give you a model that you can use to copy, paste, then edit  
> * As an example, [here is the JSON](media/a2-post-english.json) that the professor used to add the "asynchronous" English term - notice how the definition is packaged  
> 
> * When you are entering a non-English term, use one of the official [language codes](https://pam-2020-a2and3webapi.herokuapp.com/api/languages) (e.g. "fr-ca" or "ru" etc.)  
> * As an example, [here is the JSON](media/a2-post-other.json) that the professor used to add the "asynchronisme" French term - notice how the definition is packaged

<br>

The intention is that each student will be able to get access to a substantial collection of data, because the efforts of all 100 students in the course, each creating at least two terms, should result in about 200 sharable terms. How?

The best feature of the professor web API is the ability for YOU to DOWNLOAD the data as import-ready JSON, and then use MongoDB Compass to "import" the data into YOUR database. Open a browser, and use these URLs to download each collection:

* `/terms/english/download`  
All English terms, downloaded to your computer 

* `/terms/other/download`  
All non-English terms, downloaded to your computer 

After you have these downloaded files, you can easily import them into your own database collections. 

> What if the import tasks does not work?  
> Please CONTACT YOUR PROFESSOR, because it should work.  
>   
> What if some fields are missing when you query the data with YOUR web API code?  
> It's likely a property name or type mismatch - carefully compare your Mongoose schema with the published data. 

<br>

### Getting started, Angular app

Getting started includes generating a new project, and configuring your development environment. 

Make sure that your web API has been deployed to Heroku and Atlas, and make sure that you can interact with it correctly with Postman. This is important, because you must have confidence in the hosted app to make progress on the Angular app. 

Set up the rest of your dev environment (terminal windows, editor, browsers and tools). 

<br>

### Doing the work, initial 

(more to come)

<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>

### Testing your work

For this assignment, there is no required external testing capability. Therefore, rely on your browser tools for this step. 

<br>

### Deploy the Angular app to Heroku

Follow the guidance in the course notes, and deploy the Angular app to a new Heroku app. 

> Remember to do as noted above...  
> Update your home page component to include two standard HTML hyperlinks:  
> 1. One is the URL to your Heroku-hosted (Angular) app  
> 2. The other is the URL to your Heroku-hosted (DEN) web API 

<br>

### Grading procedure

Your professor will use a checklist during the grading process. The checklist will include items based on the assignment specifications. No, we will not distribute the checklist before the due date. 

Here's some more comments on the grading procedure:
* Part marks can be earned (it's not an all-or-nothing scheme)  
* Some marks will be earned for the deployed/hosted web API 
* Some marks will be earned for a deployed/hosted Angular app
* Each of the interaction tasks will earn marks
  * Some tasks could be "worth" more than others

Please review (again) the [information about grades](https://bti425.ca/policies#information-about-grades). To repeat one of its points, you will not earn an "A" simply for meeting a set of specifications. High grades are earned with work that is clearly better than expected (by meeting the specs). Better work includes a range of "qualitative" measures, including code quality, app and/or UI appearance, organization, content formatting, building upon foundations, and so on. 

<br>

### Reminder about academic honesty

You must comply with the College's academic honesty policy. Although you may interact and collaborate with others, you must submit your own work.

When you are ready to submit your work, you will copy some of the code in your project to plain text files, so that the My.Seneca/Blackboard "SafeAssign" tool can do its job. The next section will tell you which files to copy.

SafeAssign compares your work with that of other current and past students, and with existing works on the web. It uses techniques that are difficult to defeat. The overall goal is to identify copied work. 

<br> 

### Submitting your work

We need both the Node+Express web API and the Angular web app.  

Here's how to submit your work, before the due date and time:

#### Node+Express web API

1. Locate the folder that holds your project files. 

2. Make a copy of the folder. (You will be uploading a zipped version of the copy.)

3. Inside that folder, remove (delete) the `node_modules` folder. Your professor does NOT need that folder. Also, if it has a `.git` folder, remove that too.

4. Still in that folder, add a new folder named "MyCode". Copy these source code files to the "MyCode" folder:  
**The JavaScript (JS) file that holds the "server" code**  
**The JS file that holds the "manager" code**  
**The JS file(s) that holds the "schema" code**  
For each of these files in the MyCode folder, change the file name extension to "txt".

4. Compress/zip the copied folder. Maybe the name should be something like "webapi.zip". The zip file SHOULD be about 1MB in size. If it isn't, you haven't followed the instructions properly.

#### Angular web app 

1. Locate the folder that holds your project files. 

2. Make a copy of the folder. (You will be uploading a zipped version of the copy.)

3. Inside that folder, remove (delete) the `node_modules` folder. Your professor does NOT need that folder. Also, if it has a `.git` folder, remove that too.

4. Still in that folder, add a new folder named "MyCode". Copy these source code files to the "MyCode" folder:  
**to be determined**  
For each of these files in the MyCode folder, change the file name extension to "txt".

4. Compress/zip the copied folder. Maybe the name should be something like "angularapp.zip". The zip file SHOULD be about 1MB in size. If it isn't, you haven't followed the instructions properly.

#### Bundle both of them together

Ideally, bundle both of the zip files from above into a single zip file, maybe named something like "assignment2.zip". Then...

Login to My.Seneca.  
Open the course area.  
Click the "Assignments" link on the left-side navigator.  
Follow the link for this assignment.  
Submit/upload your zip file. The page will accept three submissions, so if you upload, then decide to fix something and upload again, you can do so.

<br>
